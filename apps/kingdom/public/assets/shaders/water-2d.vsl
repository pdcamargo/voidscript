/**
 * Water 2D Effect Shader
 *
 * A comprehensive water shader with reflections, waves, foam, and wetness effects.
 * Uses SCREEN_TEXTURE for real-time reflections of the scene above the water.
 *
 * Usage:
 * 1. Add Sprite2D component with a texture (can be transparent)
 * 2. Add Sprite2DMaterial component with this shader
 * 3. Adjust uniforms via the inspector
 */
shader_type canvas_item;
render_mode unshaded;

// Water surface position (0 = bottom, 1 = top)
uniform float surface_position : hint_range(0.0, 1.0) = 0.0;

// Water color (RGB) and opacity (A) combined
// Default: vec4(0.26, 0.23, 0.73, 0.25) - purple-blue tint
uniform vec4 water_color : source_color = vec4(0.26, 0.23, 0.73, 0.25);

// Reflection distortion (subtle noise-based imperfection)
uniform float distortion_amount : hint_range(0.0, 0.05) = 0.005;
uniform float distortion_speed : hint_range(0.0, 1.0) = 0.1;
uniform float distortion_scale : hint_range(1.0, 40.0) = 8.0;

// Water texture (foam/surface pattern)
uniform bool enable_water_texture = true;
uniform vec2 foam_scale = vec2(6.5, 5.4);
uniform float foam_speed : hint_range(0.0, 0.1) = 0.02;
uniform float foam_intensity : hint_range(0.0, 2.0) = 1.0;
uniform float foam_threshold : hint_range(0.0, 1.0) = 0.7;
uniform float foam_softness : hint_range(0.0, 1.0) = 1.0;
uniform float foam_turbulence : hint_range(0.0, 1.0) = 0.3;
uniform float foam_animation_speed : hint_range(0.0, 5.0) = 0.5;
uniform int foam_layer_count : hint_range(1, 5) = 2;

// Reflection settings
uniform float reflection_offset_x : hint_range(-1.0, 1.0) = 0.0;
uniform float reflection_offset_y : hint_range(-1.0, 1.0) = 0.0;
uniform float reflection_skew_x : hint_range(-1.0, 1.0) = 0.0;
uniform float reflection_skew_y : hint_range(-1.0, 1.0) = 0.1;

// Wetness effect (caustics-like pattern on top of water)
uniform float wetness_intensity : hint_range(0.0, 10.0) = 5.55;
uniform float wetness_opacity : hint_range(0.0, 2.0) = 1.0;
uniform vec2 wetness_scale = vec2(8.0, 12.0);
uniform float wetness_speed : hint_range(0.0, 0.1) = 0.03;
uniform vec2 wetness_detail_scale = vec2(20.0, 30.0);
uniform float wetness_detail_speed : hint_range(0.0, 0.1) = 0.015;
uniform float wetness_contrast : hint_range(0.0, 50.0) = 28.6;
uniform float wetness_brightness : hint_range(0.0, 2.0) = 0.1;
uniform vec3 wetness_color_tint = vec3(0.9, 0.95, 1.0);

// Tile size for world-space tiling - patterns repeat every tile_size world units
// Higher values = larger patterns (less tiling). Independent of mesh scale.
uniform float tile_size : hint_range(0.1, 500.0) = 50.0;

// Parallax animation - controls speed difference between near/far
// 0 = uniform speed, 1 = maximum parallax (top moves at 0% speed)
uniform float parallax_strength : hint_range(0.0, 1.0) = 0.7;

// Noise texture 1: Distortion noise - used for wave animation and wetness detail
// Matches original: scale=4 (frequency), octaves=3, lacunarity=1 (minimal freq increase), gain=0.5
uniform sampler2D noise_texture : hint_default_texture("fbm", 512, 512, 4.0, 3, 1.0, 0.5, 0);

// Noise texture 2: Foam noise - used for water surface texture and wetness base
// Matches original: scale=15 (frequency), octaves=3, lacunarity=4 (strong freq increase), gain=0.5
uniform sampler2D noise_texture2 : hint_default_texture("fbm", 512, 512, 15.0, 3, 4.0, 0.5, 1);

void fragment() {
    vec2 uv = UV;

    // Calculate scale factor for world-space independent tiling
    // This normalizes the UV so that patterns look the same regardless of mesh scale
    // A mesh at scale 1400 will have the same pattern density as a mesh at scale 100
    // tile_size controls how many world units per pattern repeat
    vec2 world_scale_factor = MESH_WORLD_SCALE / tile_size;

    // Parallax: bottom (uv.y=0) = full speed, top (uv.y=1) = reduced speed
    float parallax_speed = mix(1.0, 1.0 - parallax_strength, uv.y);

    // Calculate subtle noise-based distortion for reflection imperfection
    vec2 distortion_uv = uv * distortion_scale * world_scale_factor;
    distortion_uv += TIME * distortion_speed * 0.1;
    float noise_val = texture(noise_texture, distortion_uv).r - 0.5;  // Center around 0

    // Get mesh screen-space bounds (minX, minY, maxX, maxY in UV space 0-1)
    float water_min_x = MESH_SCREEN_BOUNDS.x;
    float water_min_y = MESH_SCREEN_BOUNDS.y;
    float water_max_x = MESH_SCREEN_BOUNDS.z;
    float water_max_y = MESH_SCREEN_BOUNDS.w;
    float water_width = water_max_x - water_min_x;
    float water_height = water_max_y - water_min_y;

    // Calculate depth factor for perspective (Mode 7 style)
    float depth_factor = 1.0 - uv.y; // 0 at top (surface), 1 at bottom (far)

    // Calculate X position with perspective skew
    float water_center_x = water_min_x + water_width * 0.5;
    float signed_x = (uv.x - 0.5) * 2.0; // -1 on left, +1 on right
    float skew = signed_x * depth_factor * reflection_skew_x;

    float pixel_x = water_center_x + (uv.x - 0.5) * water_width * (1.0 + skew);

    // For reflection: sample from ABOVE the water surface
    // The water surface is at water_max_y (top of water mesh in screen space)
    // A pixel at uv.y=0 (bottom of water) should sample from the highest point above
    // A pixel at uv.y=1 (top of water) should sample from just above the surface
    float distance_from_surface = (1.0 - uv.y) * water_height;
    float reflected_y = water_max_y + distance_from_surface;

    // Apply subtle noise-based distortion to break perfect mirror look
    // distortion_amount is in screen UV space, so it's consistent regardless of mesh size
    vec2 reflection_uv = vec2(
        pixel_x + noise_val * distortion_amount + reflection_offset_x,
        reflected_y + noise_val * distortion_amount * 0.5 + reflection_offset_y
    );

    // Apply vertical scaling if needed
    if (reflection_skew_y != 0.0) {
        float water_center_y = water_min_y + water_height * 0.5;
        float vertical_scale = 1.0 + depth_factor * reflection_skew_y;
        float offset_y = (reflection_uv.y - water_center_y) * (vertical_scale - 1.0);
        reflection_uv.y += offset_y;
    }

    // Clamp to prevent sampling outside screen bounds
    reflection_uv = clamp(reflection_uv, 0.001, 0.999);

    vec4 reflection = texture(SCREEN_TEXTURE, reflection_uv);

    // Blend reflection with water color using water_color.a as opacity
    vec4 final_color = mix(reflection, vec4(water_color.rgb, 1.0), water_color.a);

    // Add foam/water texture effect (multi-layer like old shader)
    if (enable_water_texture) {
        float soft_edge = foam_softness * 0.01;
        float foam_value = 0.0;

        // Layer 1: Static base foam (always visible, provides baseline)
        vec2 foam_uv1 = uv * foam_scale + uv * world_scale_factor;
        foam_uv1.x += TIME * foam_speed * parallax_speed;
        foam_uv1.y += sin(TIME * foam_speed * 2.0 * parallax_speed + uv.x * 3.0) * foam_turbulence * 0.1;
        float foam1 = texture(noise_texture2, foam_uv1).r;
        float base_layer = smoothstep(foam_threshold - soft_edge, foam_threshold + soft_edge, foam1);
        foam_value = base_layer * 0.4;

        // Layer 2: Primary animated foam (pulsing)
        if (foam_layer_count >= 2) {
            vec2 foam_uv2 = uv * (foam_scale * 0.7) + uv * world_scale_factor * 0.8;
            foam_uv2.x += TIME * foam_speed * 0.8 * parallax_speed;
            foam_uv2.y += TIME * foam_speed * foam_turbulence * 0.25 * parallax_speed;
            float foam2 = texture(noise_texture2, foam_uv2).r;
            float layer2 = smoothstep(foam_threshold - soft_edge, foam_threshold + soft_edge, foam2);
            float pulse2 = 0.5 + abs(sin(TIME * foam_animation_speed)) * 0.5;
            foam_value += layer2 * pulse2 * 0.35;
        }

        // Layer 3: Secondary animated foam (offset phase)
        if (foam_layer_count >= 3) {
            vec2 foam_uv3 = uv * (foam_scale * 1.5) + uv * world_scale_factor * 1.2;
            foam_uv3.x += TIME * foam_speed * 0.4 * parallax_speed;
            foam_uv3.y += sin(TIME * foam_speed * 1.5 * parallax_speed + uv.x * 5.0) * foam_turbulence * 0.15;
            float foam3 = texture(noise_texture2, foam_uv3).r;
            float layer3 = smoothstep(foam_threshold - soft_edge, foam_threshold + soft_edge, foam3);
            float pulse3 = 0.5 + abs(sin(TIME * foam_animation_speed * 1.3 + 1.57)) * 0.5;
            foam_value += layer3 * pulse3 * 0.25;
        }

        // Apply foam intensity
        final_color.rgb = mix(final_color.rgb, vec3(1.0), foam_value * foam_intensity);
    }

    // Add wetness/caustics effect (dual layer like old shader)
    if (wetness_intensity > 0.0) {
        // Base wetness layer - large scale flowing patterns (uses noise_texture2)
        vec2 wetness_uv = uv * wetness_scale + uv * world_scale_factor;
        wetness_uv.x += TIME * wetness_speed * parallax_speed;
        float wetness_base = texture(noise_texture2, wetness_uv).r;

        // Detail wetness layer - fine scale variation (uses noise_texture)
        vec2 detail_uv = uv * wetness_detail_scale + uv * world_scale_factor * 0.5;
        detail_uv.x += TIME * wetness_detail_speed * parallax_speed;
        detail_uv.y += sin(TIME * 0.5 * parallax_speed + uv.x * 3.0) * 0.02;
        float wetness_detail = texture(noise_texture, detail_uv).r;

        // Combine layers (70% base, 30% detail)
        float wetness_value = wetness_base * 0.7 + wetness_detail * 0.3;

        // Apply contrast and brightness
        wetness_value = clamp((wetness_value - 0.5) * wetness_contrast + 0.5 + wetness_brightness, 0.0, 1.0);

        // Apply wetness color
        final_color.rgb += wetness_color_tint * wetness_value * wetness_intensity * wetness_opacity;
    }

    // Apply surface position masking (optional - for partial water coverage)
    if (surface_position > 0.0) {
        float surface_mask = smoothstep(surface_position - 0.01, surface_position + 0.01, uv.y);
        final_color.a *= surface_mask;
    }

    COLOR = final_color;
}
